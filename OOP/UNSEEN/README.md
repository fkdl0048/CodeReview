# 객체지향 프로그래밍: 객체지향 프로그래밍 특징

관련 책을 어느정도 읽어서 개념에 대한 넓은 이해는 있지만, 문제가 지엽적으로 출제될 경우는 자신이 없다.

따라서 관련 내용에 대해서 용어 정리와 내가 생각하는 객체지향에 관해 더 적어볼 생각

## 객체지향이란? (내 생각)

내가 생각하는 객체지향은 객체간의 협력을 통해 의사소통하는 과정을 말하는 것 같다.

대부분 객체지향을 지향하면서도 절차지향적인 코드를 짜기 마련인데, 객치 자체를 지향한다는 의미와 내부적으론 절차지향을 포함하고 있다고 생각한다.

절차지향이라고 해서 객체지향이 아닌 것은 아니며 객체지향은 그보다 한 단계 높은 설계관점에서 유리한 프로그래밍 패러다임같다. (더 큰 프로그램을 설계 하기 위함)

장점은 크게 가독성, 중복 최소화, 유연한 코드 등이 있을 수 있다.

객체지향으로 설계하는 방법에는 가장 크게 주어진 도메인 모델을 생각하여 객체간의 협력(메시지)를 은유하여 표현한다. 이를 인터페이스로 드러내고 각 객체마다의 역할과 책임을 추상적으로 생각한다. 이 과정이 동적 모델을 설계하는 과정이고 이후 이를 투사하여 정적 모델(클래스)로 나타내는 과정이 실제로 코딩하는 과정이다.

대부분은 바로 코드를 치면서 작업하지만 이제는 객체의 동적인 협력을 생각하고, 구조를 설계하는 것이 더 중요한 것을 알게된 것 같다.

이 과정은 테스트 코드를 짜는 과정에서 많이 훈련이 된 것 같다고 느끼고, 단순하게 몇 달 공부한다고 좋아진다고 생각하지 않는다.

가장 좋은 객체지향 설계를 보는 방법은 SOLID도 있지만, 자신이 작성한 클래스의 이름과 Public메서드를 나열해보는 것이다.

해당 클래스의 책임이 제대로 할당되어 있는지 직관적으로 알 수 있다.

완벽한 설계는 없고 매번 다른 설계가 나올 수 있다. 이는 지속적인 개선이 필요한데, 객체지향은 이런 과정이 매우 유리하다.

## 객체지향이란? (책)

*객체지향 책에 관련된 내용을 간략하게 정리*

- [객체지향 사고 프로세스](https://fkdl0048.github.io/bookreview/bookreview_The_Object-Oriented_Thought_Process/)
- [객체지향의 사실과 오해](https://fkdl0048.github.io/bookreview/bookrevuew_Object-oriented_Facts_and_Misunderstandings/)

- 고전적인 객체지향: 캡슐화 상속 다형성
  - 합성의 추가
- 객체란?
  - 속성과 행위의 집합
  - (생각) 말 그대로 객체 자체, 클래스와 전혀 다르다.
- 객체간의 의사소통
  - 메시지로 이뤄어짐 (다른 객체의 메서드 호출)
- 객체지향 사고방식
  - 인터페이스와 구현부의 차이점
  - 더 추상적으로 생각
  - 사용자에게 가능한 한 인터페이스를 적게 제공하기
- 좋은 인터페이스의 설계
  - 구현부를 변경하더라도 사용자는 자신의 코드를 변경하지 않아도 된다. (SOLID)
- 필요이상의 API를 노출하지 않아야 한다. (캡슐화)
- 낮은 결합과 높은 응집도의 설계
- SOLID
  - SRP: 단일 책임 원칙(Single Responsibility Principle)
    - 클래스를 변경한 이유가 단일해야 한다. (네이밍에 맞는 책임만 가져야 함)
  - OCP: 개방-폐쇄 원칙(Open-Closed Principle)
    - 클래스를 수정하지 않고 클래스의 행위를 확장할 수 있어야 한다.
    - 개방/폐쇄 원리는 자식 클래스를 통해 코드를 확장해야 하며, 원래 클래스는 변경할 필요가 없다는 것이다.
    - 이 과정은 연쇄적으로 일어나기에 LSP를 제외한 다른 원칙이 준수되게 된다.
  - LSP: 리스코프 치환 원칙(Liskov Substitution Principle)
    - 부모 클래스의 인스턴스를 해당 자식 클래스 중 하나의 인스턴스로 교체할 수 있게 설계해야 한다.
  - ISP: 인터페이스 분리 원칙(Interface Segregation Principle)
    - 몇 개의 큰 인터페이스가 있는 편보다는 작은 인터페이스가 많은 편이 바람직하다.
  - DIP: 의존성 역전 원칙(Dependency Inversion Principle)
    - 코드가 추상화에 의존해야 한다고 명시하고 있다.
- 어떤 객체도 섬이 아니다.

## 객체지향이란? (정보 글)

*사실 이런 내용이 중요하다고 생각되지 않는다. 위 내용을 다 이해하고 읽으면 많은 정보를 담은 글 인걸 알겠지만, 이것을 읽고 공부한다면 무의미한 발차기라고 생각한다.*

객체 지향 프로그래밍 (Object-Oriented Programming, OOP)은 프로그래밍에서 필요한 데이터를 추상화 시켜 상태와 행위를 가진 객체로 만들고, 객체들간의 상호작용을 통해 로직을 구성하는 프로그래밍 방법이다.

객체는 프로그램에서 사용되는 데이터 또는 식별자에 의해 참조되는 공간을 의미하며 값을 저장 할 변수와 작업을 수행 할 메소드를 서로 연관된 것들끼리 묶어서 만든 것을 객체라고 할 수 있다.

객체 지향 프로그래밍은 크게 추상화 , 캡슐화 , 상속 , 다형성 의 네가지 특징을 가진다.

- 추상화
  - 객체에서 공통된 속성과 행위를 추출 하는 것
  - 공통의 속성과 행위를 찾아서 타입을 정의하는 과정
  - 추상화는 불필요한 정보는 숨기고 중요한 정보만을 표현함으로써 프로그램을 간단하게 만드는 것
- 캡슐화
  - 데이터 구조와 데이터를 다루는 방법들을 결합 시켜 묶는 것 (변수와 함수를 하나로 묶는 것을 뜻함)
  - **낮은 결합도**를 유지할 수 있도록 설계하는 것
  - 정보 은닉의 효과를 불러올 수 있지만 그것이 핵심이 아닌 객체지향적 관점에서 봐야 한다.
- 상속
  - 클래스의 속성과 행위를 하위 클래스에 물려주거나 하위 클래스가 상위 클래스의 속성과 행위를 물려받는 것을 말한다
  - 새로운 클래스가 기존의 클래스의 데이터와 연산을 이용할 수 있게 하는 기능
  - 단점이 명확하게 존재, 합성이 더 유리하다고 말할 수 있음
- 다형성
  - 하나의 변수명, 함수명이 상황에 따라 다른 의미로 해석 될 수 있는 것
  - 어떠한 요소에 여러 개념을 넣어 놓는 것
- 객체지향 프로그래밍의 장단점
  - 장점
    - 클래스 단위로 모듈화시켜서 개발하기 때문에 업무 분담이 편리하고 대규모 소프트웨어 개발에 적합하다.
    - 클래스 단위로 수정이 가능하기 때문에 유지 보수가 편리하다.
    - 클래스를 재사용하거나 상속을 통해 확장함으로써 코드 재사용이 용이하다.
  - 처리속도가 상대적으로 느리다.
  - 객체의 수가 많아짐에 따라 용량이 커질 수 있다.
  - 설계시 많은 시간과 노력이 필요하게 될 수 있다.
- 객체 지향 프로그래밍의 반대는 절차 지향 프로그래밍이다?
  - 객체 지향 프로그래밍은 절차 지향 프로그래밍과 장단점이 겹치는 부분이 있기 때문에 그렇게 생각이 들 수 있다. 하지만 절차지향은 순차적으로 실행에 초점이 되어있고 객체지향은 관계/조직에 초점을 맞추고 있다는 초점의 차이일 뿐이다. 절차적 프로그래밍이라고 해서 객체를 다루지 않는 것이 아니고, 객체지향 프로그래밍이라고해서 절차가 없는 것도 아니다.
- 단일 책임 원칙 (SRP, Single Responsibility Principle)
  - 하나의 클래스는 단 하나의 책임만 가져야 한다.
  - 단일 책임 원칙을 지키지 않을 경우 한 책임의 변경에 의해 다른 책임과 관련된 코드에 영향이 갈 수 있다.
- 개방-폐쇄 원칙 (OCP, Open/Closed Principle)
  - 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
  - 기능을 변경하거나 확장할 수 있으면서 기능을 사용하는 코드는 수정하지 않는다.
- 리스코프 치환 원칙 (LSP, Liskov Substitution Principle)
  - 프로그램 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
  - 상위 타입의 객체를 하위 타입의 객체로 치환해도, 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.
- 인터페이스 분리 원칙 (ISP, Interface Segregation Principle)
  - 범용 인터페이스 하나보다 클라이언트를 위한 여러 개의 인터페이스로 구성하는 것이 좋다.
  - 인터페이스는 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.
  - 클라이언트가 필요로 하는 인터페이스로 분리함으로써 각 클라이언트가 사용하지 않는 인터페이스에 변경이 있어도 영향을 받지 않도록 만들어야 한다.
- 의존관계 역전 원칙 (DIP, Dependency Inversion Principle)
  - 추상화에 의존해야지 구체화에 의존하면 안된다.
  - 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안되고 저수준 모듈은 고수준 모듈에서 정의한 추상 타입에 의존해야 한다.
- 장점(2)
  - 프로그램을 보다 유연하고 변경이 용이하게 만들 수 있다.
  - 각각의 부품이 독립적인 역할을 갖기 때문에 코드의 변경을 최소화하고 유지보수하는 데 유리하다.
  - 코드의 재사용을 통해 반복적인 코드를 최소화하고 코드를 간결하게 표현할 수 있다.
  - 인간이 세상을 바라보는 관점을 도입했기 때문에 이전보다 인간 친화적이고 직관적인 코드를 작성하기에 용이하다.
