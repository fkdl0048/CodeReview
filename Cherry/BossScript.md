# 2차 버전 첫번째 보스 제작 과정  

사실 별 생각 없이 행동 패턴 fsm모델을 적용해서 보스나 몬스터를 1차 버전 그리고 2차 버전 몬스터에 적용했다.  

별로 좋은 형태가 아니라는 것은 알고 있지만 작동이 되어야 한다는 부담감에 무작정 작성했던 것 같다.  

좋은 결과를 얻은 건 다행이지만 성장했다는 느낌은 받기 어려웠다.  

최근에는 조금 성장했다는 느낌을 받아서 기록한다.  

1. 문제점을 직면하고 책을 통한 밸런스를 맞출려고함  

*사실 아직도 많이 부족함을 느끼지만 기록을 해야 더 성장할 것 같았다.*

## 최대한 중복을 줄이자  

상속이나 인터페이스를 무작정 활용하기 보다 적재적소에 맞게 사용이 중요하다.  

객체지향을 제대로 사용해보고 싶다는 생각이 정말 크다.(이번년도가 끝나기 전엔 제대로 사용하고 싶다.)  

```cs
states[(int)CommonState.Attack] = patterns[patternIndex];
```

가장 좋다고 생각한 부분이다.  

상태라고 해서 보스 공격패턴을 7가지를 전부 상태에 넣는 것이 아닌 공격으로 분류하고 패턴은 따로 만들어 공격시작마다 해당 패턴을 넣어주는 방법이다.  

여기서 해당 패턴의 인터페이스까지 활용하여 각기 다른 공격타이밍에 공격이 가능하게 분류했다.  

```cs
patterns[patternIndex].Attack();
```

> public class Pattern : State<SewerBoss>, IBossAttack

```cs
public interface IBossAttack
{
    public void Attack();
}
```

이 처럼 공격에 따른 패턴을 따로 빼서 패턴하나당 하나의 클래스로 fsm으로 관리하고 전부 IBossAttack을 상속받았다.  

보스라는 클래스자체는 확연하게 줄어들었고 패턴, 상태마다의 해당 네임스페이스 공간에 따로 정리하니 확장성 모듈화를 확보한 것 같다.  

물론 아직도 public private 메서드의 목적이 불분명하다.  

이는 멘토님께서도 지적해주신 부분으로 해당 클래스에서 분리할 수 있는 부분이 보이면 객체로 분류해서 가지고 있는 형태로 변형을 추천해주셨다.  

1. 가독성: 가독성 측면을 확보하지 못했다. 
2. 모듈화: 3점,,?
3. 재상용성 및 일반화: 하위문제로 분류했다고 하지만 사람마다 주관적인 부분이 있어서 조금 아쉽다.
4. 테스트 용이성: 테스트 코드를 한번도 짜보지 못했다.  