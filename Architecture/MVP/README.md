# MVP

![image](https://github.com/BRIDGE-DEV/BRIDGE_Archive/assets/84510455/e8988ebf-f070-4cff-8569-8f8e0173aeef)

매우매우 단순한 그림이지만 이걸 바로 이해하기는 힘들다. (나는 그랬다.)

MVP를 처음 접한다면 마찬가지로 아키텍처에 관한 책이나 경험이 부족한 것일 수 있다.

MVP패턴에 동작 순서는 다음과 같다.

- 사용자의 입력이 view를 통해 들어옴
- view가 Presenter에게 이벤트를 알림(데이터를 요청)
- Presenter는 Model에게 데이터를 요청
- Model은 데이터 로직을 처리하여 Presenter에게 데이터를 전달
- Presenter는 View에게 데이터를 전달(응답)
- View는 Presenter로부터 받은 데이터를 통해 UI를 업데이트

View와 Presenter는 1:1로 연결되어 있으며, Presenter와 Model은 1:N으로 연결될 수 있다.

*View와 Presenter간의 1:1 의존성이 높아진다..*

실제로 만들어 보면서 이해하는게 가장 좋은 방법이기에 적당한 예제를 구해서 클론코딩해보는 것을 추천

(유니티로 구현)

## 구조에 대한 생각

가장 먼저 MVP패턴의 핵심이 되는 Presenter를 먼저 이해해야 한다.

사전적의미로 **진행자**라고 하는데, 뭘 진행한다는 걸까?

Model은 데이터를 받아서 처리하는 비즈니스 로직이고 View는 말 그대로 사용자에게 보여지는 UI, Presenter은 view로부터 이벤트를 받아와 처리하고 모델에게 알려주어 업데이트하는 방식이다.

유니티 설계로 생각해본다면, Model은 데이터를 다루기 때문에 단순 데이터 클래스로 만들어도 된다.

그렇다면 유용한 ScriptableObject를 사용하면 유용할 수 있다.

내부에 데이터를 불변으로 지정하여 저장하고, 데이터에 관한 로직을 정리해두면 쉽게 사용가능하다.

설정창에서 모델은 SettingsData라는 ScriptableObject를 사용하면 될 것 같다.
*게임 특성상 SettingData도 인게임중에 활용될 수 있기 때문에 의존성을 위해*

다음은 View로 유니티에서는 Canvas에 해당되는 UI를 사용하면 된다.

즉, MonoBehaviour를 상속받은 클래스를 사용하여 하이어라키상에 존재하여 직접적인 이벤트를 받아서 처리하게 만들면 된다.

마지막으로 Presenter은 view와 Model을 연결하는 역할을 한다.

두 컴포넌트에 대한 참조를 가지고 있으나 굳이 MonoBehaviour를 상속받을 필요는 없다.

여기서 진행자는 해당 로직을 처리하는 핵심적인 역할이므로 이에 대한 테스트가 먼저 진행되어야 도메인이 확실하게 보인다.

요구되는 기능은 사용자가 설정창의 볼륨을 조절하는 간단한 기능이다.

코드는 레포에 첨부되어 있으니 참고하면 좋을 것 같다.

*테스트 코드는 Test폴더에 첨부되어 있다.*