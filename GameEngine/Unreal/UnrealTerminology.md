# 언리얼 엔진 용어 정리

엔진을 사용하기 이전에 언리얼 엔진에서 사용하는 용어에 대한 이해를 하고 넘어가려고 한다.

## 프로젝트(Project)

언리얼 엔진 5 프로젝트는 게임의 모든 콘텐츠를 담고 있다. 프로젝트에는 `Blueprints`, `C++ 코드`등 많은 폴더가 포함되며 언리얼 데이터의 콘텐츠 브라우저패널을 통해 실제 폴더와 같은 디렉토리 구조를 볼 수 있다.

모든 프로젝트에는 연관된 .uproject 파일이 있으며, 이 파일로 프로젝트를 생성하거나, 열거나, 저장할 수 있다.

![image](https://github.com/fkdl0048/CodeReview/assets/84510455/0dba7ae8-6f7a-4100-9baf-4ed146254f4a)

## 블루프린트(Blueprint)

블루프린트 비주얼 스크립팅(Bluetprint Visual Scripting)시스템 노드(Node) 기반의 인터페이스를 사용하여 언리얼 에디터 내의 게임플레이 엘리먼트를 생성하는 완전한 게임플레이 스크립팅 시스템이다.

일반적인 스크립팅 언어와 마찬가지로 블루프린트도 오브젝트 지향 클래스 또는 오브젝트를 정의하기 위해 사용된다.

이 시스템은 매우 유연하고 강력해서 보통 프로그래머가 없으면 힘들었던 개념 구현이나 툴 작업을 디자이너가 할 수있을 정도로 강력하다.

*유니티의 코볼과 비슷한 개념이라고 생각하면 된다. or 쉐이더 그래프*

## 오브젝트(Object)

오브젝트는 언리얼에서 가장 기본적인 클래스로 기본적인 구성 단위의 역할을 한다. 대부분 모든 것이 오브젝트로 부터 상속 받거나 함수 기능을 사용한다.

`Unreal C++`에서 `UObject`는 모든 오브젝트의 베이스 클래스다. 가비지 콜렉션, 언리얼 에디터에 변수를 노출하기 위한 메타데이터(`UPROPERTY`)지원, 로딩 및 저장 직렬화 등의 기능을 구현한다.

그렇다면 내부 로직에선 다른 `UObject`를 상속받지 않은 `C++`코드로 로직을 분리하는 형태는 동일해보인다.

*유니티와 마찬가지로 하나의 Object클래스를 가지고, UPROPERTY는 SerializeField와 비슷한 개념인 것 같다.*

## 클래스(Class)

클래스는 언리얼 엔진에서 특정 액터나 오브젝트의 행동과 프로퍼티를 정의한다. 클래스는 계층적이며 상속 구조를 기본으로 가진다.

클래스는 `C++`코드나 블루프린트로 생성될 수 있다.

*유니티와 동일한 개념이다.*

## 액터(Actor)

액터는 카메라, 스태틱 메시, 플레이어 스타트 위치 등과 같이 레벨에 배치할 수 있는 모든 오브젝트를 가리킨다. 액터는 이동, 회전, 스케일링 등의 3D 트랜스폼을 지원한다.

또한 `C++`또는 블루프린트 게임플레이 코드를 통해 생성 및 소멸될 수 있다.

`C++`에서 `AActor`클래스는 모든 액터의 베이스 클래스이다.

*유니티에선 트랜스폼을 컴포넌트로 컴포넌트 패턴으로 구현되어 있다면, 언리얼은 상속을 기본구조로 해당 구조를 구분한다.*

## 형변환(Casting)

형변환은 특정 클래스의 액터를 다른 클래스인 것처럼 간주하려 시도하는 작업이다. 형변환은 성공할 수도 있고 실패할 수 있다. 성공하면 형변환한 액터의 클래스 전용 기능에 액세스할 수 있다.

일반적인 형변환의 개념과 유사하지만, 언리얼 엔진의 특성상 특별한 메커니즘과 함수들을 제공한다. `Cast<>`라는 탬플릿 함수를 사용하여 형변환을 시도할 수 있다.

*유니티에선 GetComponent에 해당하는 기능이라고 생각이 된다..?*

## 컴포넌트(Component)

컴포넌트는 액터에 추가할 수있는 기능 조각이다. 액터에 컴포넌트를 추가하면, 액터는 해당 컴포넌트가 제공하는 기능을 사용할 수 있다.

- 액터에 추가되어야 하며, 단독으로는 존재할 수 없다.

*유니티와 동일한 컴포넌트 패턴의 기능이다.*

## 폰(Pawn)

폰은 액터의 서브클래스이며, 인게임 아바타 또는 페르소나의 역할을 한다. 폰은 플레이어 또는 게임AI로 제어되는 NPC등이 있다.

인간이나 AI 플레이어가 폰을 제어하면 그 폰은 빙의된 상태로 간주한다. 반대로 제어하지 않은 폰은 빙의 해제된것으로 여겨진다.

*캐릭터로 확장하기 위한 상위 클래스로 보인다. 제어 가능한 오브젝트를 설명하기 위해, 자율성을 남겨둔 클래스라 생각된다?*

## 캐릭터(Character)

캐릭터는 플레이어 캐릭터로 사용하기 위한 폰 액터의 서브 클래스이다. 캐릭터 클래스에는 쿨리전 설정, 바이페드 움직임을 위한 입력 바인딩, 플레이어가 제어하는 움직임을 위한 추가 코드등이 포함된다.

## 플레이어 컨트롤러(Player Controller)

플레이어 컨트롤러는 플레이어의 입력을 게임 안의 상호작용으로 변환한다. 모든 게임에는 최소의 하나의 컨트롤러가 있다. 플레이어 컨트롤러는 게임 안에서 플레이어를 나타내는 폰이나 캐릭터에 빙의할 때가 많다.

플레이어 컨트롤러는 멀티 플레이 게임의 주요한 네트워크 상호작용 지점입니다. 멀티 플레이 게임동안 서버가 각 플레이어에게 네트워크 함수 호출을 할 수 있어야 하기에 게임 안의 모든 플레이어에 대해 하나의 컨트롤러 인스턴스를 지닌다.

연관된 `C++`클래스는 `APlayerController`이다.

## AI 컨트롤러(AI Controller)

AI 컨트롤러는 게임 안에 NPC를 나타내는 폰을 소유한다.

연관된 `C++`클래스는 `AAIController`이다.

## 플레이어 스테이트(Player State)

플레이어 스테이트는 게임 참여자의 스테이트를 말한다.

- 이름
- 현재 레벨
- ...

멀티플레이 게임의 경우 모든 컴퓨터에 모든 플레이어의 플레이어 스테이트가 존재하며, 동기화를 유지하기 위해 서버에서 클라이언트로 데이터를 리플리케이트할 수 있다.

연관된 `C++`클래스는 `APlayerState`이다.

## 게임 모드(Game Mode)

게임 모드는 플레이 중인 게임의 규칙을 설정한다.

- 플레이어가 게임에 참여하는 방법
- 게임의 일시 정지 기능 여부
- 승리 조건 등 게임 전용 행동

프로젝트 세팅에서 디폴트 게임 모드를 설정하고 레벨별로 오버라이드할 수 있다. 어떤 방법으로 구현하든, 한 레벨에는 하나의 게임 모드만 존재할 수 있다.

연관된 `C++`클래스는 `AGameMode`이다.

## 게임 스테이트(Game State)

게임 스테이트는 게임 내의 모든 클라이언트에 복제할 정보가 들어 있는 컨테이너이다. 쉽게 말해 연결된 모든 사람에 대한 '게임 스테이트'를 말한다.

- 게임 점수에 대한 정보
- 대결이 시작됐는지 여부
- 월드에 있는 플레이어 수를 기준으로 스폰할 AI 캐릭터의 수

마찬가지로 멀티의 경우 각 플레이어 마다 하나씩 있다.

연관된 `C++`클래스는 `AGameState`이다.

## 브러시(Brush)

브러시는 큐브, 구체와 같은 3D 세이프를 묘사하는 액터이다. 레벨에 브러시를 배치하여 레벨 지오메트리를 정의할 수 있다. 이를 바이너리 스페이스 파티션또는 BSP 브러시라고 한다.

## 불륨(Volume)

불륨은 연결된 효과에 따라 용도가 달라지는 바운드 된 3D 공간이다.

- 블로킹 볼륨
  - 보이지 않으며 액터가 통과하지 못한다.
- 페인 코징 볼륨
  - 오버랩되는 액터에 시간이 지남에 따라 대미지를 준다.
- 트리거 볼륨
  - 액터가 들어오거나 나갈 때 이벤트를 유발하도록 프로그래밍된다.

## 레벨(Level)

레벨은 스스로 정의하는 게임플레이 영역으로 레벨에는 지오메트리, 폰, 액터와 같이 플레이어가 보고 상호작용하는 모든 것이 포함된다.

언리얼엔진에서는 각 레벨을 별도의 `.umap`파일로 저장한다. 따라서 맵으로 불리기도 한다.

*하나의 스테이지, 맵 형태라고 생각된다.*

## 월드(World)

월드는 게임을 구성하는 모든 레벨이 담겨있는 컨테이너이다. 월드는 레벨의 스트리밍과 다이내믹 액터의 스폰을 처리한다.

*유니티의 씬과 비슷한 개념이라고 생각된다.*

## 정리

유니티와 비슷한 점은 많은 부분이 닮아있긴 하지만 대체적으로 상속구조를 통해 게임이라면 가질 수밖에 없는 부분을 미리 설계해놨다는 점이 인상깊다.

게임이라는 도메인에 맞춰서 설계되어서 인지 게임 모드, 게임 스테이트와 같이 애초에 게임이라는 틀을 정해놓은 느낌

---

https://docs.unrealengine.com/5.0/ko/unreal-engine-terminology/