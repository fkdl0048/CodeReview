# C++의 메모리 구조

C++은 C의 성격을 가지기에 low-level의 메모리 구조를 가지고 있다. C++의 메모리 구조는 크게 4가지로 나눌 수 있다.

1. 코드 영역 (Code Segment)
2. 데이터 영역 (Data Segment)
3. 힙 영역 (Heap Segment)
4. 스택 영역 (Stack Segment)

## 코드 영역 (Code Segment)

코드 영역은 실행할 프로그램의 코드가 저장되는 영역이다. CPU는 코드 영역에 저장된 명령어를 하나씩 가져가서 처리한다. 이 영역은 텍스트 영역이라고도 불린다.

## 데이터 영역 (Data Segment)

데이터 영역은 프로그램의 전역 변수와 정적 변수가 저장되는 영역이다. 데이터 영역은 프로그램의 시작과 함께 할당되며 프로그램이 종료되면 소멸한다.

힙 영역보다 아래에 위치한다.

## 힙 영역 (Heap Segment)

힙 영역은 동적으로 할당된 메모리가 저장되는 영역이다. 힙 영역은 사용자가 직접 관리해야 한다. 힙 영역은 메모리를 할당하고 해제하는데 사용된다.

힙역역은 사용자가 직접 메모리를 할당하고 해제하는데 사용된다. 힙 영역은 메모리를 할당하고 해제하는데 사용된다. 즉, 사용자의 사용에 따라 메모리 leak이 발생할 수 있다.

아래 스택은 말 그대로 쌓이는 구조이기 때문에 간단하지만, 힙은 메모리에 직접할당되고 연속적이지 않기 때문에 복잡하다. 이를 사용자가 관리하기 위해선 스택 영역에 해당 힙 영역의 주소를 저장해놓아야 한다. (포인터)

데이터 영역보다 위에 위치한다. 불연속적인 메모리 영역이기 때문에 메모리를 할당하고 해제하는데 사용된다.

C++에서는 `new`와 `delete` 키워드를 사용하여 힙 영역을 사용할 수 있다. *C에선 `malloc`과 `free`를 사용한다. but C++에선 클래스를 중심으로 설계하기 때문에 `new`와 `delete`를 사용한다.*

```cpp
int* p = new int;
delete p;
```

하지만 Safe한 메모리 할당을 위해 `std::unique_ptr`, `std::shared_ptr`, `std::weak_ptr`를 사용한다.

### 힙 영역이 필요한 이유

- Life Cycle
  - 스택 영역으로만 동작한다면 함수가 종료되면 메모리가 해제되기 때문에, 동적으로 메모리를 할당하고 해제할 수 있는 힙 영역이 필요하다.
- Size
  - 스택 영역은 크기가 작기 때문에, 동적으로 메모리를 할당하고 해제할 수 있는 힙 영역이 필요하다. 힙에 큰 오브젝트를 할당하고 스택은 해당 참조만 가지고 있으면 된다.
- Dynamic Memory Allocation
  - 동적으로 메모리를 할당하고 해제할 수 있는 힙 영역이 필요하다. (Runtime에 메모리를 할당하고 해제할 수 있다.)

스택보단 느리지만, 위의 이유로 인해 힙 영역이 필요하다.

## 스택 영역 (Stack Segment)

스택 영역은 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역이다. 스택 영역은 함수의 호출과 함께 할당되며 함수의 호출이 끝나면 소멸한다. 스택 영역은 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역이다. 스택 영역은 함수의 호출과 함께 할당되며 함수의 호출이 끝나면 소멸한다.

가장 위쪽 메모리 주소를 먹고 시작하며 아래로 내려가면서 메모리를 사용한다.

- 스택 영역은 쌓이는 구조이기 때문에 할당가 해제가 간단/빠르다.
- 런타임에 일어난다. (힙도 마찬가지로 런타임)
- Stack overflow가 발생할 수 있다. (limit이 있기 때문에)

### 스택 프레임 (Stack Frame)

스택 영역에는 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는데, 이때 저장되는 정보를 스택 프레임이라고 한다. 스택 프레임은 함수의 호출과 함께 생성되고 함수의 호출이 끝나면 소멸한다.

- 이는 실제 함수나 구조체, 클래스 등이 실제 메모리 stack에 저장될 때, 차례대로 쌓여가는 것이 아닌 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역이다.
- 말 그대로 프레임으로 이해하면 좋다.

### 스택 프레임의 구조

스택 프레임은 크게 3가지로 나눌 수 있다.

1. 함수의 매개변수 (Parameter)
2. 함수의 지역 변수 (Local Variable)
3. 함수의 리턴 주소 (Return Address)

```cpp
#include <iostream>

void foo(int a, int b)
{
    int c = a + b;
    std::cout << c << std::endl;
}

int main()
{
    foo(1, 2);
    return 0;
}
```

이 코드에서 실제 메모리에 저장되는 스택 프레임은 다음과 같다.

```
|-------------------|
|       3           | <- c
|-------------------|
|       2           | <- b
|-------------------|
|       1           | <- a
|-------------------|
|   return address  | <- main
|-------------------|
```

*이 때문에 연속된 주소처럼 보이지 않는 것이다. (예제를 테스트할 때..)*

추가적으로 클래스의 멤버 함수는 똑같이 함수 단위로 스택 프레임이 생성된다. 또한 멤버 변수를 접근하기 위해서 `this` 포인터가 사용된다.

```cpp
#include <iostream>

class foo
{
public:
    void bar(int a, int b)
    {
        int c = a + b;
        std::cout << c << std::endl;
    }
};

int main()
{
    foo f;
    f.bar(1, 2);
    return 0;
}
```

이 코드에서 실제 메모리에 저장되는 스택 프레임은 다음과 같다.

```
|-------------------|
|       3           | <- c
|-------------------|
|       2           | <- b
|-------------------|
|       1           | <- a
|-------------------|
|   return address  | <- main
|-------------------|
|       this        | <- f
|-------------------|
```

실제로 클래스의 메서드의 동작이 low-level에서 어떻게 동작하는지 이해하면 설계에 도움이 되기 때문에 이러한 지식은 중요하다..