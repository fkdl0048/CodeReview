# C++ 컴파일 프로세스

순서를 크게 나누면 다음과 같다.

- 전처리기(Preprocessor)
- 컴파일러(Compiler)
- 어셈블러(Assembler)
- 링커(Linker)

## 전처리기(Preprocessor)

전처리기는 소스 코드 파일에 대해 여러 가지 사전 처리를 수행합니다. 이 단계에서는 다음 작업이 수행됩니다:

매크로 확장: #define으로 정의된 매크로를 확장합니다.
파일 포함: #include 지시문을 처리하여 헤더 파일을 포함합니다.
조건부 컴파일: #if, #ifdef, #ifndef, #else, #elif, #endif 등을 처리하여 조건부로 컴파일할 코드 블록을 결정합니다.
기타 전처리기 지시문 처리: #pragma 등의 기타 지시문을 처리합니다.
전처리 결과는 확장된 소스 코드 파일입니다.

실제로 이 단계에서는 헤더 파일이 실제 CPP코드에 복사되는 것이다. 이를 방지하기 위헤서 `#pragma once`를 사용한다.

그리고, 다른 매크로도 마찬가지로 조건에 따라 코드 자체가 포함되지 않을 수 있다.

이 과정을 통해 translate unit이라는 것이 생성된다.

## 컴파일러(Compiler)

컴파일러는 전처리된 소스 코드를 기계어 코드로 변환하는 역할을 합니다. 이 단계는 여러 하위 단계로 나뉩니다:

이는 컴파일러가 컴파일하는 최소 단위이다. 내부에는 각 Cpp마다 data, code 영역이 생긴다.

### 어휘 분석 (Lexical Analysis)

소스 코드를 토큰(token)으로 분할합니다. 토큰은 프로그래밍 언어의 기본 단위입니다. 예를 들어, 키워드, 식별자, 연산자, 구두점 등이 토큰이 될 수 있습니다.

### 구문 분석 (Syntax Analysis)

토큰 시퀀스를 구문 트리(parse tree) 또는 추상 구문 트리(Abstract Syntax Tree, AST)로 변환합니다. 이 단계에서는 소스 코드의 구문 구조를 확인하고, 구문 오류를 검출합니다.

### 의미 분석 (Semantic Analysis)

AST를 바탕으로 의미 분석을 수행합니다. 여기서는 타입 체크(type checking), 변수 범위(scope) 검사, 일관성 검사 등을 수행합니다.

### 중간 코드 생성 (Intermediate Code Generation)

플랫폼 독립적인 중간 코드를 생성합니다. 이는 최적화와 기계어 코드 생성을 용이하게 합니다.

### 최적화 (Optimization)

중간 코드 또는 기계어 코드를 최적화하여 성능을 개선합니다. 이 단계에서는 코드의 크기를 줄이거나 실행 속도를 높이기 위해 다양한 최적화 기법을 적용합니다.

### 기계어 코드 생성 (Code Generation)

중간 코드를 플랫폼에 특화된 기계어 코드로 변환합니다. 이 단계에서 실제로 실행 가능한 명령어로 변환됩니다.

## 어셈블러 (Assembler)

어셈블러는 기계어 코드를 목적 파일(object file)로 변환합니다. 목적 파일은 기계어 코드와 데이터, 심볼 테이블(symbol table) 등을 포함하는 이진 파일입니다.

## 링커 (Linker)

링커는 여러 목적 파일과 라이브러리를 결합하여 **최종 실행 파일(executable)**을 생성합니다. 링커의 주요 작업은 다음과 같습니다:

심볼 해결 (Symbol Resolution): 각 목적 파일에 정의된 심볼과 참조된 심볼을 결합합니다.
주소 지정 (Address Allocation): 코드와 데이터를 메모리 주소에 배치합니다.
라이브러리 포함 (Library Inclusion): 필요한 라이브러리 파일을 포함하여 링크합니다.
요약
C++ 컴파일러는 소스 코드를 실행 파일로 변환하기 위해 여러 단계를 거칩니다:

전처리기: 코드 전처리.
컴파일러: 어휘 분석, 구문 분석, 의미 분석, 중간 코드 생성, 최적화, 기계어 코드 생성.
어셈블러: 기계어 코드를 목적 파일로 변환.
링커: 목적 파일과 라이브러리를 결합하여 실행 파일 생성.
이 모든 단계를 거쳐 최종적으로 실행 가능한 프로그램이 생성됩니다

## 정리

실제 동작 과정과 헤더파일의 의미, 그리고 전처리기의 역할을 이해하는 것이 중요하다. 특히, 헤더파일은 실제 코드를 복사하는 것이기 때문에 중복을 방지하기 위해 `#pragma once`를 사용한다.

그렇다면 헤더파일에는 `include`를 사용하는 것이 맞을까? 헤더파일 내부에서 사용하는 타입이나 조건에 따라 다르다. 만약 내부에서 vector와 같은 자료형이 필요하다면 사용한다. 그렇지 않다면 cpp에서만 사용한다.

- ""는 사용자 정의 헤더파일
- <>는 시스템 헤더파일