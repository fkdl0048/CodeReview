# C++ 바이트 패딩

쉽게 공간을 더 써서 메모리를 효율적으로 사용하는 방법이다. 이는 운영체제에 따라 다르게 동작한다. (32비트, 64비트)

실제 구조체에 `int`와 `short`가 있다고 가정해보자.

```cpp
struct MyStruct {
    int a;
    short b;
};
```

이 구조체의 크기는 6바이트가 된다. 이는 `int`가 4바이트, `short`가 2바이트이기 때문이다.

하지만, 컴파일러는 바이트 패딩을 통해 8바이트로 정렬한다. 이는 CPU가 8바이트 단위로 데이터를 읽어오기 때문이다.

32비트 CPU는 4바이트 단위로 데이터를 읽어오기 때문에 4바이트로 정렬한다. 64비트 CPU는 8바이트 단위로 데이터를 읽어오기 때문에 8바이트로 정렬한다.

따라서 선언 시의 위치도 효율적으로 배치해야 한다. 구조체/클래스 패딩은 구조체 안의 가장 큰 자료형의 크기로 정해진다. *꼭 큰 자료형으로 정해지는 것은 아니다.*

## Example

```cpp
struct Example {
    char a;   // 1 byte
    int b;    // 4 bytes
    char c;   // 1 byte
};
```

```cpp
|  a  | pad | pad | pad |  b  |  b  |  b  |  b  |  c  | pad | pad | pad |
| 1B  | 1B  | 1B  | 1B  | 1B  | 1B  | 1B  | 1B  | 1B  | 1B  | 1B  | 1B  |
```

위의 구조체는 12바이트가 된다. `int`는 4바이트이므로 4바이트로 정렬된다. 따라서 `char`는 1바이트이지만 4바이트로 정렬된다.

## Rule

바이트 패딩에는 룰이 존재한다. Memory Alignment라고도 한다.

- 멤버 변수는 자신의 크기의 배수에서 시작해야 한다.
  - 즉, `int`는 4바이트 단위로 시작해야 한다.
  - 따라서 멤버변수의 순서가 `int`, `double`순서라면 8바이트로 정렬된다. 따라서 4바이트가 패딩된다.
- 오브젝트의 전체 사이즈는 가장 큰 멤버 변수의 배수여야 한다.

### Advanced Rule (false sharing)

**false sharing**을 방지하기 위해 패딩을 사용할 수 있다. false sharing은 멀티코어 CPU에서 발생하는 문제로, 캐시 라인을 공유하는 것을 말한다.

```cpp
class alignas(64) MyStruct { // or aignas(32)
    int a;
    short b;
};
```

False sharing은 멀티스레드 프로그램에서 성능을 저하시키는 주요 원인 중 하나입니다. 이는 서로 다른 스레드가 동일한 캐시 라인(cache line)을 공유하는 변수를 수정할 때 발생합니다. 각 스레드는 서로 다른 변수를 사용하지만, 이 변수들이 동일한 캐시 라인에 속해 있기 때문에 한 스레드의 수정이 다른 스레드의 캐시를 무효화하여 성능 저하를 초래합니다.

#### 캐시 라인

캐시 메모리는 CPU와 메인 메모리 사이의 속도 차이를 줄이기 위해 사용됩니다. 캐시는 일반적으로 64바이트 크기의 블록(캐시 라인)으로 나뉩니다. 동일한 캐시 라인에 속한 데이터는 함께 캐시에 로드됩니다.

## 정리

- 바이트 패딩: 데이터 구조의 멤버 변수를 정렬하기 위해 추가되는 바이트. 메모리 접근을 효율적으로 만들기 위해 사용됩니다.
- False sharing: 멀티스레드 환경에서 서로 다른 스레드가 동일한 캐시 라인을 수정할 때 발생하는 성능 저하. 이를 방지하기 위해 변수 사이에 패딩을 추가하거나 정렬을 적절히 조정할 수 있습니다.

## 참고

- [참고 자료](https://coding-factory.tistory.com/670)
- [C++ 자료형의 크기](../DataType/README.md)