# Rendering Pipeline

렌더링 파이프라인에 대해 정리합니다.

## 요약

크게 렌더링 파이프라인은 그래픽스의 과정을 단계별로 나누면 다음과 같다.

vertex shader -> resterization -> fragment shader

### Vertex Shader

버텍스 쉐이더는 정점을 변환하는 역할을 한다.

현재 FOV에서 보이는 물체를 정점으로 표현하고, 이를 변환하여 화면에 출력한다.

한개의 물체를 vertex shader를 통해 변환하는 과정은 다음과 같다.

Model -> world -> camera -> view

#### 변환과정

1. Model: 물체의 위치, 크기, 방향 등을 정의한다.
2. World: 물체를 월드 좌표계로 변환한다.
3. Camera: 물체를 카메라 좌표계로 변환한다.
4. View: 물체를 화면에 출력할 수 있도록 변환한다.

한 오브젝트를 화면에 출력하기 위해선 이러한 변환과정을 거쳐야 한다.

한 정점과 삼각형마다 각 과정이 적용되며, 이는 GPU를 통해 매우 빠르게 계산된다. (행렬 연산)

이 과정을 끝내면 현재 FOV에서 보이는 물체를 정점으로 표현하게 된다.

*실제로는 코드로 존재하는 가상의 물체를 위치를 행렬로 매우 빠르게 계산하여 정점의 형태로 변환하여 반환하는 것이다.*

```
Modeling Transformation (모델 변환):
목적: 모델 변환은 3D 객체의 로컬 좌표 공간을 월드 좌표 공간으로 변환하는 데 사용됩니다. 이 변환은 객체의 위치, 회전 및 크기를 조절하며, 다수의 모델을 월드 공간에 배치할 수 있도록 합니다. 즉, 객체의 모양과 위치를 조정하는 데 사용됩니다.

Viewing Transformation (뷰 변환):
목적: 뷰 변환은 월드 좌표 공간에서의 객체의 위치를 카메라의 시점으로 변환합니다. 이 변환은 관찰자의 시선 방향, 시점 위치, 카메라의 방향 및 업 벡터 등을 고려하여 월드 좌표 공간을 카메라 좌표 공간으로 변환합니다. 즉, 뷰 변환은 카메라의 시각을 설정하는 데 사용됩니다.

Projection Transformation (투영 변환):
목적: 투영 변환은 뷰 공간의 3D 좌표를 2D 이미지 평면에 투영하는 데 사용됩니다. 이 변환은 원근 투영 또는 직교 투영과 같은 투영 기법을 적용하여 객체를 화면 공간으로 투영하고, 원근 및 깊이 효과를 생성합니다. 즉, 화면에 표시할 영역을 정의하고 원근 효과를 추가하는 데 사용됩니다.
```

각 계산은 행렬로 계산되며, 이는 GPU에서 매우 빠르게 계산된다.

### Rasterization

버텍스 쉐이더를 통해 변환된 정점들을 삼각형으로 변환한다. (폴리곤)

삼각형으로 변환하는 과정은 내부에 픽셀을 채우는 과정을 포함한다. 현재 해상도에 따라 생성되는 픽셀의 크기가 달라지며 해당 픽셀의 수에 따라 삼각형의 크기가 달라진다.

앞서 주어진 정점들을 가지고 각 x와 y좌표를 계산하고 삼각형 내부를 픽셀로 채우는 과정을 거친다. RGB값을 계산하여 해당 픽셀의 색을 결정한다.

가시성을 생각하여 z Buffer를 사용하여 가장 가까운 픽셀을 선택한다. (Depth-Buffer라고도 함) 즉, 다른 오브젝트에 의해서 가려지는 경우 뒤에 있는 오브젝트는 그릴 필요가 없다. z좌표는 이전 단계에서 x,y좌표말고도 카메라의 거리에 따라 달라지며, 이를 통해 가시성을 판단한다.

### Fragment Shader

프래그먼트 쉐이더는 픽셀을 색칠하는 역할을 한다.

플래그먼트 쉐이딩은 좀 더 사실적인 렌더링을 위해 사용된다. (Phong Shading, Ray Tracing 등) 이를 통해 더 자연스러운 렌더링을 할 수 있다.

각각의 픽셀들은 색을 결정할 때, 선형 보간법을 사용하여 색을 결정한다. (Gouraud Shading) (하기도 한다?)

실제 빛의 효과를 계산하기 위해선 빛의 방향, 물체의 방향, 물체의 색 등을 고려하여 계산한다.

삼각형마다 표면의 노말 벡터를 계산하고, 이를 통해 빛의 방향을 계산한다. 이를 통해 빛의 반사, 굴절 등을 계산할 수 있다.

- Normal Vector: 표면의 방향을 나타내는 벡터
  - 공식: N = (P1-P0) x (P2-P0) (외적)
  - P0, P1, P2: 삼각형의 정점
  - 외적을 통해 계산된 벡터는 방향을 나타내며, 이를 통해 빛의 반사, 굴절 등을 계산할 수 있다.
- 렘브트 반사: 빛의 반사를 나타내는 것으로, 빛의 방향과 노말 벡터의 내적을 통해 계산한다.
  - 공식: L = normalize(L), N = normalize(N), R = 2(N.L)N - L
  - L: 빛의 방향, N: 노말 벡터, R: 렘브트 반사 벡터
  - but 실제 환경에서 0~1 사이의 값으로 나타내기 위해선 max(0, R.V)^n을 사용한다. (너무 어두워지는 것을 방지) 따라서 환경에 따라 다르게 계산된다. 주변 빛의 영향을 받는다.

각 삼각형이 자신의 노말 벡터로만 색을 결정하면 사실적인 묘사가 부족하기 때문에 삼각형 끼리의 노말 벡터를 계산하여 더 자연스러운 렌더링을 할 수 있다.